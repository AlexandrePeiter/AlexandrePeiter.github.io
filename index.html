<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebXR AR with Three.js</title>
  <style>
    body { margin: 0; overflow: hidden; }
    button {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 1;
      font-size: 1.2em;
      padding: 10px;
    }
  </style>
</head>
<body>
  <button id="addSphereBtn">Adicionar Esfera</button>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js';
    import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.1/examples/jsm/webxr/ARButton.js';

    let camera, scene, renderer;
    let controller;
    let reticle; // indicador da superfície plana

    init();
    animate();

    function init() {
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera();

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.xr.setReferenceSpaceType('local');
      document.body.appendChild(renderer.domElement);

      document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      scene.add(light);

      // Reticle (indicador de superfície plana)
      const reticleGeometry = new THREE.RingGeometry(0.1, 0.11, 32).rotateX(-Math.PI / 2);
      const reticleMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      reticle = new THREE.Mesh(reticleGeometry, reticleMaterial);
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);

      // Hit test
      let hitTestSource = null;
      let hitTestSourceRequested = false;

      controller = renderer.xr.getController(0);
      scene.add(controller);

      renderer.setAnimationLoop((timestamp, frame) => {
        if (frame) {
          const referenceSpace = renderer.xr.getReferenceSpace();
          const session = renderer.xr.getSession();

          if (!hitTestSourceRequested) {
            session.requestReferenceSpace('viewer').then((refSpace) => {
              session.requestHitTestSource({ space: refSpace }).then((source) => {
                hitTestSource = source;
              });
            });
            session.addEventListener('end', () => {
              hitTestSourceRequested = false;
              hitTestSource = null;
            });
            hitTestSourceRequested = true;
          }

          if (hitTestSource) {
            const hitTestResults = frame.getHitTestResults(hitTestSource);
            if (hitTestResults.length) {
              const hit = hitTestResults[0];
              const pose = hit.getPose(referenceSpace);
              reticle.visible = true;
              reticle.matrix.fromArray(pose.transform.matrix);
            } else {
              reticle.visible = false;
            }
          }
        }

        renderer.render(scene, camera);
      });

      // Botão para adicionar a esfera
      document.getElementById('addSphereBtn').addEventListener('click', () => {
        if (!reticle.visible) {
          alert('Superfície não detectada. Aponte para uma superfície plana.');
          return;
        }

        const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 32);
        const sphereMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

        // Posição: 1.8 metros acima da superfície detectada
        const position = new THREE.Vector3();
        position.setFromMatrixPosition(reticle.matrix);
        position.y += 1.8;
        sphere.position.copy(position);

        scene.add(sphere);
      });
    }

    function animate() {
      renderer.setAnimationLoop(() => {
        renderer.render(scene, camera);
      });
    }
  </script>
</body>
</html>
